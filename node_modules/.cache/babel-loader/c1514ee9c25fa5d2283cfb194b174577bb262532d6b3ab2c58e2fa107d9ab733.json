{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst tslib_1 = require(\"tslib\");\nconst PostgrestTransformBuilder_1 = tslib_1.__importDefault(require(\"./PostgrestTransformBuilder\"));\nconst PostgrestReservedCharsRegexp = new RegExp('[,()]');\nclass PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {\n  /**\r\n   * Match only rows where `column` is equal to `value`.\r\n   *\r\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  eq(column, value) {\n    this.url.searchParams.append(column, \"eq.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is not equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  neq(column, value) {\n    this.url.searchParams.append(column, \"neq.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is greater than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  gt(column, value) {\n    this.url.searchParams.append(column, \"gt.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is greater than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  gte(column, value) {\n    this.url.searchParams.append(column, \"gte.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is less than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  lt(column, value) {\n    this.url.searchParams.append(column, \"lt.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is less than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  lte(column, value) {\n    this.url.searchParams.append(column, \"lte.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches `pattern` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\n  like(column, pattern) {\n    this.url.searchParams.append(column, \"like.\".concat(pattern));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  likeAllOf(column, patterns) {\n    this.url.searchParams.append(column, \"like(all).{\".concat(patterns.join(','), \"}\"));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  likeAnyOf(column, patterns) {\n    this.url.searchParams.append(column, \"like(any).{\".concat(patterns.join(','), \"}\"));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches `pattern` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\n  ilike(column, pattern) {\n    this.url.searchParams.append(column, \"ilike.\".concat(pattern));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  ilikeAllOf(column, patterns) {\n    this.url.searchParams.append(column, \"ilike(all).{\".concat(patterns.join(','), \"}\"));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\n  ilikeAnyOf(column, patterns) {\n    this.url.searchParams.append(column, \"ilike(any).{\".concat(patterns.join(','), \"}\"));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` IS `value`.\r\n   *\r\n   * For non-boolean columns, this is only relevant for checking if the value of\r\n   * `column` is NULL by setting `value` to `null`.\r\n   *\r\n   * For boolean columns, you can also set `value` to `true` or `false` and it\r\n   * will behave the same way as `.eq()`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\n  is(column, value) {\n    this.url.searchParams.append(column, \"is.\".concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows where `column` is included in the `values` array.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param values - The values array to filter with\r\n   */\n  in(column, values) {\n    const cleanedValues = Array.from(new Set(values)).map(s => {\n      // handle postgrest reserved characters\n      // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n      if (typeof s === 'string' && PostgrestReservedCharsRegexp.test(s)) return \"\\\"\".concat(s, \"\\\"\");else return \"\".concat(s);\n    }).join(',');\n    this.url.searchParams.append(column, \"in.(\".concat(cleanedValues, \")\"));\n    return this;\n  }\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * `column` contains every element appearing in `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\n  contains(column, value) {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, \"cs.\".concat(value));\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, \"cs.{\".concat(value.join(','), \"}\"));\n    } else {\n      // json\n      this.url.searchParams.append(column, \"cs.\".concat(JSON.stringify(value)));\n    }\n    return this;\n  }\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * every element appearing in `column` is contained by `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\n  containedBy(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, \"cd.\".concat(value));\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, \"cd.{\".concat(value.join(','), \"}\"));\n    } else {\n      // json\n      this.url.searchParams.append(column, \"cd.\".concat(JSON.stringify(value)));\n    }\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is greater than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeGt(column, range) {\n    this.url.searchParams.append(column, \"sr.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or greater than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeGte(column, range) {\n    this.url.searchParams.append(column, \"nxl.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is less than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeLt(column, range) {\n    this.url.searchParams.append(column, \"sl.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or less than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeLte(column, range) {\n    this.url.searchParams.append(column, \"nxr.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for range columns. Match only rows where `column` is\r\n   * mutually exclusive to `range` and there can be no element between the two\r\n   * ranges.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\n  rangeAdjacent(column, range) {\n    this.url.searchParams.append(column, \"adj.\".concat(range));\n    return this;\n  }\n  /**\r\n   * Only relevant for array and range columns. Match only rows where\r\n   * `column` and `value` have an element in common.\r\n   *\r\n   * @param column - The array or range column to filter on\r\n   * @param value - The array or range value to filter with\r\n   */\n  overlaps(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, \"ov.\".concat(value));\n    } else {\n      // array\n      this.url.searchParams.append(column, \"ov.{\".concat(value.join(','), \"}\"));\n    }\n    return this;\n  }\n  /**\r\n   * Only relevant for text and tsvector columns. Match only rows where\r\n   * `column` matches the query string in `query`.\r\n   *\r\n   * @param column - The text or tsvector column to filter on\r\n   * @param query - The query text to match with\r\n   * @param options - Named parameters\r\n   * @param options.config - The text search configuration to use\r\n   * @param options.type - Change how the `query` text is interpreted\r\n   */\n  textSearch(column, query) {\n    let {\n      config,\n      type\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let typePart = '';\n    if (type === 'plain') {\n      typePart = 'pl';\n    } else if (type === 'phrase') {\n      typePart = 'ph';\n    } else if (type === 'websearch') {\n      typePart = 'w';\n    }\n    const configPart = config === undefined ? '' : \"(\".concat(config, \")\");\n    this.url.searchParams.append(column, \"\".concat(typePart, \"fts\").concat(configPart, \".\").concat(query));\n    return this;\n  }\n  /**\r\n   * Match only rows where each column in `query` keys is equal to its\r\n   * associated value. Shorthand for multiple `.eq()`s.\r\n   *\r\n   * @param query - The object to filter with, with column names as keys mapped\r\n   * to their filter values\r\n   */\n  match(query) {\n    Object.entries(query).forEach(_ref => {\n      let [column, value] = _ref;\n      this.url.searchParams.append(column, \"eq.\".concat(value));\n    });\n    return this;\n  }\n  /**\r\n   * Match only rows which doesn't satisfy the filter.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to be negated to filter with, following\r\n   * PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\n  not(column, operator, value) {\n    this.url.searchParams.append(column, \"not.\".concat(operator, \".\").concat(value));\n    return this;\n  }\n  /**\r\n   * Match only rows which satisfy at least one of the filters.\r\n   *\r\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure it's properly sanitized.\r\n   *\r\n   * It's currently not possible to do an `.or()` filter across multiple tables.\r\n   *\r\n   * @param filters - The filters to use, following PostgREST syntax\r\n   * @param options - Named parameters\r\n   * @param options.referencedTable - Set this to filter on referenced tables\r\n   * instead of the parent table\r\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\r\n   */\n  or(filters) {\n    let {\n      foreignTable,\n      referencedTable = foreignTable\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const key = referencedTable ? \"\".concat(referencedTable, \".or\") : 'or';\n    this.url.searchParams.append(key, \"(\".concat(filters, \")\"));\n    return this;\n  }\n  /**\r\n   * Match only rows which satisfy the filter. This is an escape hatch - you\r\n   * should use the specific filter methods wherever possible.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to filter with, following PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\n  filter(column, operator, value) {\n    this.url.searchParams.append(column, \"\".concat(operator, \".\").concat(value));\n    return this;\n  }\n}\nexports.default = PostgrestFilterBuilder;\n//# sourceMappingURL=PostgrestFilterBuilder.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}