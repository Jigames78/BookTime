{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { base64UrlToUint8Array, bytesToBase64URL } from './base64url';\nimport { AuthError, AuthUnknownError, isAuthError } from './errors';\nimport { isBrowser } from './helpers';\nimport { identifyAuthenticationError, identifyRegistrationError, isWebAuthnError, WebAuthnError, WebAuthnUnknownError } from './webauthn.errors';\nexport { WebAuthnError, isWebAuthnError, identifyRegistrationError, identifyAuthenticationError };\n/**\r\n * WebAuthn abort service to manage ceremony cancellation.\r\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\r\n *\r\n * @experimental This class is experimental and may change in future releases\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\r\n */\nexport class WebAuthnAbortService {\n  /**\r\n   * Create an abort signal for a new WebAuthn operation.\r\n   * Automatically cancels any existing operation.\r\n   *\r\n   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\r\n   */\n  createNewAbortSignal() {\n    // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n    if (this.controller) {\n      const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n      abortError.name = 'AbortError';\n      this.controller.abort(abortError);\n    }\n    const newController = new AbortController();\n    this.controller = newController;\n    return newController.signal;\n  }\n  /**\r\n   * Manually cancel the current WebAuthn operation.\r\n   * Useful for cleaning up when user cancels or navigates away.\r\n   *\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\r\n   */\n  cancelCeremony() {\n    if (this.controller) {\n      const abortError = new Error('Manually cancelling existing WebAuthn API call');\n      abortError.name = 'AbortError';\n      this.controller.abort(abortError);\n      this.controller = undefined;\n    }\n  }\n}\n/**\r\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\r\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\r\n *\r\n * @experimental This instance is experimental and may change in future releases\r\n */\nexport const webAuthnAbortService = new WebAuthnAbortService();\n/**\r\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\r\n * as required by the WebAuthn browser API.\r\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\r\n *\r\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\r\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\r\n */\nexport function deserializeCredentialCreationOptions(options) {\n  if (!options) {\n    throw new Error('Credential creation options are required');\n  }\n  // Check if the native parseCreationOptionsFromJSON method is available\n  if (typeof PublicKeyCredential !== 'undefined' && 'parseCreationOptionsFromJSON' in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return PublicKeyCredential.parseCreationOptionsFromJSON(/** we assert the options here as typescript still doesn't know about future webauthn types */\n    options);\n  }\n  // Fallback to manual parsing for browsers that don't support the native method\n  // Destructure to separate fields that need transformation\n  const {\n      challenge: challengeStr,\n      user: userOpts,\n      excludeCredentials\n    } = options,\n    restOptions = __rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"user\", \"excludeCredentials\"]);\n  // Convert challenge from base64url to ArrayBuffer\n  const challenge = base64UrlToUint8Array(challengeStr).buffer;\n  // Convert user.id from base64url to ArrayBuffer\n  const user = Object.assign(Object.assign({}, userOpts), {\n    id: base64UrlToUint8Array(userOpts.id).buffer\n  });\n  // Build the result object\n  const result = Object.assign(Object.assign({}, restOptions), {\n    challenge,\n    user\n  });\n  // Only add excludeCredentials if it exists\n  if (excludeCredentials && excludeCredentials.length > 0) {\n    result.excludeCredentials = new Array(excludeCredentials.length);\n    for (let i = 0; i < excludeCredentials.length; i++) {\n      const cred = excludeCredentials[i];\n      result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {\n        id: base64UrlToUint8Array(cred.id).buffer,\n        type: cred.type || 'public-key',\n        // Cast transports to handle future transport types like \"cable\"\n        transports: cred.transports\n      });\n    }\n  }\n  return result;\n}\n/**\r\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\r\n * as required by the WebAuthn browser API.\r\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\r\n *\r\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\r\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\r\n */\nexport function deserializeCredentialRequestOptions(options) {\n  if (!options) {\n    throw new Error('Credential request options are required');\n  }\n  // Check if the native parseRequestOptionsFromJSON method is available\n  if (typeof PublicKeyCredential !== 'undefined' && 'parseRequestOptionsFromJSON' in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n  }\n  // Fallback to manual parsing for browsers that don't support the native method\n  // Destructure to separate fields that need transformation\n  const {\n      challenge: challengeStr,\n      allowCredentials\n    } = options,\n    restOptions = __rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"allowCredentials\"]);\n  // Convert challenge from base64url to ArrayBuffer\n  const challenge = base64UrlToUint8Array(challengeStr).buffer;\n  // Build the result object\n  const result = Object.assign(Object.assign({}, restOptions), {\n    challenge\n  });\n  // Only add allowCredentials if it exists\n  if (allowCredentials && allowCredentials.length > 0) {\n    result.allowCredentials = new Array(allowCredentials.length);\n    for (let i = 0; i < allowCredentials.length; i++) {\n      const cred = allowCredentials[i];\n      result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {\n        id: base64UrlToUint8Array(cred.id).buffer,\n        type: cred.type || 'public-key',\n        // Cast transports to handle future transport types like \"cable\"\n        transports: cred.transports\n      });\n    }\n  }\n  return result;\n}\n/**\r\n * Convert a registration/enrollment credential response to server format.\r\n * Serializes binary fields to base64url for JSON transmission.\r\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\r\n *\r\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\r\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\r\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\r\n */\nexport function serializeCredentialCreationResponse(credential) {\n  var _a;\n  // Check if the credential instance has the toJSON method\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return credential.toJSON();\n  }\n  const credentialWithAttachment = credential;\n  return {\n    id: credential.id,\n    rawId: credential.id,\n    response: {\n      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),\n      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))\n    },\n    type: 'public-key',\n    clientExtensionResults: credential.getClientExtensionResults(),\n    // Convert null to undefined and cast to AuthenticatorAttachment type\n    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n  };\n}\n/**\r\n * Convert an authentication/verification credential response to server format.\r\n * Serializes binary fields to base64url for JSON transmission.\r\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\r\n *\r\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\r\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\r\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\r\n */\nexport function serializeCredentialRequestResponse(credential) {\n  var _a;\n  // Check if the credential instance has the toJSON method\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return credential.toJSON();\n  }\n  // Fallback to manual conversion for browsers that don't support toJSON\n  // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n  // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n  const credentialWithAttachment = credential;\n  const clientExtensionResults = credential.getClientExtensionResults();\n  const assertionResponse = credential.response;\n  return {\n    id: credential.id,\n    rawId: credential.id,\n    // W3C spec expects rawId to match id for JSON format\n    response: {\n      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),\n      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),\n      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),\n      userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : undefined\n    },\n    type: 'public-key',\n    clientExtensionResults,\n    // Convert null to undefined and cast to AuthenticatorAttachment type\n    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n  };\n}\n/**\r\n * A simple test to determine if a hostname is a properly-formatted domain name.\r\n * Considers localhost valid for development environments.\r\n *\r\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\r\n *\r\n * Regex sourced from here:\r\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\r\n *\r\n * @param {string} hostname - The hostname to validate\r\n * @returns {boolean} True if valid domain or localhost\r\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\r\n */\nexport function isValidDomain(hostname) {\n  return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname)\n  );\n}\n/**\r\n * Determine if the browser is capable of WebAuthn.\r\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\r\n *\r\n * @returns {boolean} True if browser supports WebAuthn\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\r\n */\nfunction browserSupportsWebAuthn() {\n  var _a, _b;\n  return !!(isBrowser() && 'PublicKeyCredential' in window && window.PublicKeyCredential && 'credentials' in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\n}\n/**\r\n * Create a WebAuthn credential using the browser's credentials API.\r\n * Wraps navigator.credentials.create() with error handling.\r\n *\r\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\r\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\r\n */\nexport async function createCredential(options) {\n  try {\n    const response = await navigator.credentials.create(/** we assert the type here until typescript types are updated */\n    options);\n    if (!response) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Empty credential response', response)\n      };\n    }\n    if (!(response instanceof PublicKeyCredential)) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response)\n      };\n    }\n    return {\n      data: response,\n      error: null\n    };\n  } catch (err) {\n    return {\n      data: null,\n      error: identifyRegistrationError({\n        error: err,\n        options\n      })\n    };\n  }\n}\n/**\r\n * Get a WebAuthn credential using the browser's credentials API.\r\n * Wraps navigator.credentials.get() with error handling.\r\n *\r\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\r\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\r\n */\nexport async function getCredential(options) {\n  try {\n    const response = await navigator.credentials.get(/** we assert the type here until typescript types are updated */\n    options);\n    if (!response) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Empty credential response', response)\n      };\n    }\n    if (!(response instanceof PublicKeyCredential)) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response)\n      };\n    }\n    return {\n      data: response,\n      error: null\n    };\n  } catch (err) {\n    return {\n      data: null,\n      error: identifyAuthenticationError({\n        error: err,\n        options\n      })\n    };\n  }\n}\nexport const DEFAULT_CREATION_OPTIONS = {\n  hints: ['security-key'],\n  authenticatorSelection: {\n    authenticatorAttachment: 'cross-platform',\n    requireResidentKey: false,\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\n    userVerification: 'preferred',\n    residentKey: 'discouraged'\n  },\n  attestation: 'none'\n};\nexport const DEFAULT_REQUEST_OPTIONS = {\n  /** set to preferred because older yubikeys don't have PIN/Biometric */\n  userVerification: 'preferred',\n  hints: ['security-key']\n};\nfunction deepMerge() {\n  const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n  const isArrayBufferLike = val => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n  const result = {};\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n  for (const source of sources) {\n    if (!source) continue;\n    for (const key in source) {\n      const value = source[key];\n      if (value === undefined) continue;\n      if (Array.isArray(value)) {\n        // preserve array reference, including unions like AuthenticatorTransport[]\n        result[key] = value;\n      } else if (isArrayBufferLike(value)) {\n        result[key] = value;\n      } else if (isObject(value)) {\n        const existing = result[key];\n        if (isObject(existing)) {\n          result[key] = deepMerge(existing, value);\n        } else {\n          result[key] = deepMerge(value);\n        }\n      } else {\n        result[key] = value;\n      }\n    }\n  }\n  return result;\n}\n/**\r\n * Merges WebAuthn credential creation options with overrides.\r\n * Sets sensible defaults for authenticator selection and extensions.\r\n *\r\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\r\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\r\n * @param {string} friendlyName - Optional friendly name for the credential\r\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\r\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\r\n */\nexport function mergeCredentialCreationOptions(baseOptions, overrides) {\n  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\r\n * Merges WebAuthn credential request options with overrides.\r\n * Sets sensible defaults for user verification and hints.\r\n *\r\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\r\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\r\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\r\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\r\n */\nexport function mergeCredentialRequestOptions(baseOptions, overrides) {\n  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\r\n * WebAuthn API wrapper for Supabase Auth.\r\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\r\n *\r\n * @experimental This API is experimental and may change in future releases\r\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\r\n */\nexport class WebAuthnApi {\n  constructor(client) {\n    this.client = client;\n    // Bind all methods so they can be destructured\n    this.enroll = this._enroll.bind(this);\n    this.challenge = this._challenge.bind(this);\n    this.verify = this._verify.bind(this);\n    this.authenticate = this._authenticate.bind(this);\n    this.register = this._register.bind(this);\n  }\n  /**\r\n   * Enroll a new WebAuthn factor.\r\n   * Creates an unverified WebAuthn factor that must be verified with a credential.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\r\n   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\r\n   */\n  async _enroll(params) {\n    return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {\n      factorType: 'webauthn'\n    }));\n  }\n  /**\r\n   * Challenge for WebAuthn credential creation or authentication.\r\n   * Combines server challenge with browser credential operations.\r\n   * Handles both registration (create) and authentication (request) flows.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\r\n   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\r\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\r\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\r\n   * @returns {Promise<RequestResult>} Challenge response with credential or error\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\r\n   */\n  async _challenge(_ref, overrides) {\n    let {\n      factorId,\n      webauthn,\n      friendlyName,\n      signal\n    } = _ref;\n    try {\n      // Get challenge from server using the client's MFA methods\n      const {\n        data: challengeResponse,\n        error: challengeError\n      } = await this.client.mfa.challenge({\n        factorId,\n        webauthn\n      });\n      if (!challengeResponse) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();\n      /** webauthn will fail if either of the name/displayname are blank */\n      if (challengeResponse.webauthn.type === 'create') {\n        const {\n          user\n        } = challengeResponse.webauthn.credential_options.publicKey;\n        if (!user.name) {\n          user.name = \"\".concat(user.id, \":\").concat(friendlyName);\n        }\n        if (!user.displayName) {\n          user.displayName = user.name;\n        }\n      }\n      switch (challengeResponse.webauthn.type) {\n        case 'create':\n          {\n            const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n            const {\n              data,\n              error\n            } = await createCredential({\n              publicKey: options,\n              signal: abortSignal\n            });\n            if (data) {\n              return {\n                data: {\n                  factorId,\n                  challengeId: challengeResponse.id,\n                  webauthn: {\n                    type: challengeResponse.webauthn.type,\n                    credential_response: data\n                  }\n                },\n                error: null\n              };\n            }\n            return {\n              data: null,\n              error\n            };\n          }\n        case 'request':\n          {\n            const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n            const {\n              data,\n              error\n            } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {\n              publicKey: options,\n              signal: abortSignal\n            }));\n            if (data) {\n              return {\n                data: {\n                  factorId,\n                  challengeId: challengeResponse.id,\n                  webauthn: {\n                    type: challengeResponse.webauthn.type,\n                    credential_response: data\n                  }\n                },\n                error: null\n              };\n            }\n            return {\n              data: null,\n              error\n            };\n          }\n      }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in challenge', error)\n      };\n    }\n  }\n  /**\r\n   * Verify a WebAuthn credential with the server.\r\n   * Completes the WebAuthn ceremony by sending the credential to the server for verification.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Object} params - Verification parameters\r\n   * @param {string} params.challengeId - ID of the challenge being verified\r\n   * @param {string} params.factorId - ID of the WebAuthn factor\r\n   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\r\n   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\r\n   * */\n  async _verify(_ref2) {\n    let {\n      challengeId,\n      factorId,\n      webauthn\n    } = _ref2;\n    return this.client.mfa.verify({\n      factorId,\n      challengeId,\n      webauthn: webauthn\n    });\n  }\n  /**\r\n   * Complete WebAuthn authentication flow.\r\n   * Performs challenge and verification in a single operation for existing credentials.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Object} params - Authentication parameters\r\n   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\r\n   * @param {Object} params.webauthn - WebAuthn configuration\r\n   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\r\n   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\r\n   * @param {AbortSignal} params.webauthn.signal - Optional abort signal\r\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\r\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\r\n   */\n  async _authenticate(_ref3, overrides) {\n    let {\n      factorId,\n      webauthn: {\n        rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\n        rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\n        signal\n      }\n    } = _ref3;\n    if (!rpId) {\n      return {\n        data: null,\n        error: new AuthError('rpId is required for WebAuthn authentication')\n      };\n    }\n    try {\n      if (!browserSupportsWebAuthn()) {\n        return {\n          data: null,\n          error: new AuthUnknownError('Browser does not support WebAuthn', null)\n        };\n      }\n      // Get challenge and credential\n      const {\n        data: challengeResponse,\n        error: challengeError\n      } = await this.challenge({\n        factorId,\n        webauthn: {\n          rpId,\n          rpOrigins\n        },\n        signal\n      }, {\n        request: overrides\n      });\n      if (!challengeResponse) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      const {\n        webauthn\n      } = challengeResponse;\n      // Verify credential\n      return this._verify({\n        factorId,\n        challengeId: challengeResponse.challengeId,\n        webauthn: {\n          type: webauthn.type,\n          rpId,\n          rpOrigins,\n          credential_response: webauthn.credential_response\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in authenticate', error)\n      };\n    }\n  }\n  /**\r\n   * Complete WebAuthn registration flow.\r\n   * Performs enrollment, challenge, and verification in a single operation for new credentials.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Object} params - Registration parameters\r\n   * @param {string} params.friendlyName - User-friendly name for the credential\r\n   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\r\n   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\r\n   * @param {AbortSignal} params.signal - Optional abort signal\r\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\r\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\r\n   */\n  async _register(_ref4, overrides) {\n    let {\n      friendlyName,\n      rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\n      rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\n      signal\n    } = _ref4;\n    if (!rpId) {\n      return {\n        data: null,\n        error: new AuthError('rpId is required for WebAuthn registration')\n      };\n    }\n    try {\n      if (!browserSupportsWebAuthn()) {\n        return {\n          data: null,\n          error: new AuthUnknownError('Browser does not support WebAuthn', null)\n        };\n      }\n      // Enroll factor\n      const {\n        data: factor,\n        error: enrollError\n      } = await this._enroll({\n        friendlyName\n      });\n      if (!factor) {\n        await this.client.mfa.listFactors().then(factors => {\n          var _a;\n          return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find(v => v.factor_type === 'webauthn' && v.friendly_name === friendlyName && v.status !== 'unverified');\n        }).then(factor => factor ? this.client.mfa.unenroll({\n          factorId: factor === null || factor === void 0 ? void 0 : factor.id\n        }) : void 0);\n        return {\n          data: null,\n          error: enrollError\n        };\n      }\n      // Get challenge and create credential\n      const {\n        data: challengeResponse,\n        error: challengeError\n      } = await this._challenge({\n        factorId: factor.id,\n        friendlyName: factor.friendly_name,\n        webauthn: {\n          rpId,\n          rpOrigins\n        },\n        signal\n      }, {\n        create: overrides\n      });\n      if (!challengeResponse) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      return this._verify({\n        factorId: factor.id,\n        challengeId: challengeResponse.challengeId,\n        webauthn: {\n          rpId,\n          rpOrigins,\n          type: challengeResponse.webauthn.type,\n          credential_response: challengeResponse.webauthn.credential_response\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in register', error)\n      };\n    }\n  }\n}\n//# sourceMappingURL=webauthn.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}